# Readme

## 4月26日

发现可以写成rust特征的形式啊，帅炸了

## 节点链接方案

节点之间的链接实际上是需要不同的线程同时循环的
那么就存在几种方案，

- 多开命令行运行多个main函数，我们显然是可以在每个子包内写main的
- 在main函数中分多线程，调用不同的子包的函数，这样的化公共空间会多一些，之间的通讯除了ros还有其他方案
- 用python启动多个节点，但是这样会遮蔽编译报错等信息，令人颇为不爽

最终决定用1，2 方案合并，如果运行主包内的mian函数，那么就开多线程，同时保留各自子包内的main函数

## 分层方案

最底层是物理层或者仿真层，包括主体机器人、辅助机构、传感器等，以及他们的状态设置与数据获取部分的附属代码，一般由商家提供。ducker考虑。

rust端控制器主要用于接受规划器的目标点。

rust端规划器接受真实物理空间的数据并整理为优化问题并发给求解器，求解器处理完成后检查结果并输出给控制器层

rust端迭代器主要用于接受py端迭代器的任务并新建任务队列，两端共享一个 `config.json` ，每个 `config.json` 具备一个唯一的版本号，每个任务存在一个 `task.json` ，`task.json` 中包含一个检查 `config` 的键值对，每次执行任务前检查任务是否对齐。执行任务时控制器参数和规划器参数需要每次更新吗？不一定，`config.json` 中主要给出选出的控制器与规划器类型与初始值，但是对于控制器规划器的参数迭代还得靠 `task.json` ，整体的数据存储结构为单次实验中选定唯一的控制器与规划器，在每次任务下有多个迭代处理任务，每次任务中向规划器发布一个任务，每个任务需要存储每帧的规划数据、控制数据、执行数据。

按照这个结构来说 `config.json` + `task.json` 是有意义的。
`config.json` 在于说明本次实验的相关参数记录，包括选用的控制器、规划器、物理仿真层、迭代参数等
`task.json` 在于记录本次任务中的任务参数记录，包括选用的控制器、规划器参数等。

理论上来说根据 `config.json` 可以得到唯一的实验流程和实验结果，所以应该有唯一的识别码，建议识别码方式为时间作为id或者随机数作为id，不过毕竟之后还是要整理数据的，这里建议用时间作为id吧

@import "crates/controller/readme.md"
