# Readme

## 项目说明

本项目是一个机械臂仿真实验平台，用于多种机器人及控制器、规划期的实验对照。

本项目主体采用 rust 写就，迭代器及仿真器/物理硬件层 采用 python/c++ 写就。采用ros框架进行节点通讯和记录。

rust 子包在 `/crates` 目录下，python 子包在 `/scripts` 目录下

## 节点链接方案

节点之间的链接实际上是需要不同的线程同时循环的
那么就存在几种方案，

- 多开命令行运行多个main函数，我们显然是可以在每个子包内写main的
- 在main函数中分多线程，调用不同的子包的函数，这样的化公共空间会多一些，之间的通讯除了ros还有其他方案
- 用python启动多个节点，但是这样会遮蔽编译报错等信息，令人颇为不爽

最终决定用1，2 方案合并，如果运行主包内的mian函数，那么就开多线程，同时保留各自子包内的main函数

## 分层方案

最底层是物理层或者仿真层，包括主体机器人、辅助机构、传感器等，以及他们的状态设置与数据获取部分的附属代码，一般由商家提供。ducker考虑。

机器人结构应该分为机器人状态结构体和机器人参数结构体，机器人状态包括其姿态、速度、此时的雅可比矩阵等信息，机器人参数结构体存储机器人姿态边界、关节数量、机器人相关尺寸等信息。
但是机器人的参数并非固定的，甚至是不是机械臂类型的机器人都不一定，应该以一个特征实现，给一个Robot特征，所有机器人继承这个特征

rust端仿真器主要是用来做简单对拍的，py端和c++端仿真器才是大头。仿真器具备接受控制信息，返回机器人状态结构体

rust端控制器主要用于接受规划器的目标点。

rust端规划器接受真实物理空间的数据并整理为优化问题并发给求解器，求解器处理完成后检查结果并输出给控制器层

rust端迭代器主要用于接受py端迭代器的任务并新建任务队列，两端共享一个 `config.json` ，每个 `config.json` 具备一个唯一的版本号，每个任务存在一个 `task.json` ，`task.json` 中包含一个检查 `config` 的键值对，每次执行任务前检查任务是否对齐。执行任务时控制器参数和规划器参数需要每次更新吗？不一定，`config.json` 中主要给出选出的控制器与规划器类型与初始值，但是对于控制器规划器的参数迭代还得靠 `task.json` ，整体的数据存储结构为单次实验中选定唯一的控制器与规划器，在每次任务下有多个迭代处理任务，每次任务中向规划器发布一个任务，每个任务需要存储每帧的规划数据、控制数据、执行数据。

按照这个结构来说 `config.json` + `task.json` 是有意义的。
`config.json` 在于说明本次实验的相关参数记录，包括选用的控制器、规划器、物理仿真层、迭代参数等
`task.json` 在于记录本次任务中的任务参数记录，包括选用的控制器、规划器参数等。

理论上来说根据 `config.json` 可以得到唯一的实验流程和实验结果，所以应该有唯一的识别码，建议识别码方式为时间作为id或者随机数作为id，不过毕竟之后还是要整理数据的，这里建议用时间作为id吧

### Robot

### controller

控制器模块，接受来自规划器的执行目标，控制机器人执行。

每个控制器应该实现什么内容呢

控制器接受的信息来自两方面，一方面是来自于规划器的规划结果（关节空间内），一方面是来自于仿真器的信息反馈

规划器的规划结果形状是固定的，由于控制器帧率高于规划期帧率，控制器内需要保存一个目标值，并订阅规划器发布话题。

控制器需要机器人运行参数和相关边界条件，如何做到不同机器人层分离
