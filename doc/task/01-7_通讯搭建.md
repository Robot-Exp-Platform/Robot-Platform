# 01-7 通讯搭建

## 相关关键词

> zmq ros ros2 节点

## 任务目标

task_manager 向 planner 发布目标同时从 planner 监听目标完成情况， planner 向 controller 发布轨迹点同时向 task_manager 汇报任务完成情况，controller 向 simulator 发布控制指令 ， simulator 监听仿真器返回的 机器人状态，并复写 robot

显然，无论从哪层发布，都需要任务队列管理，有此出现了两种方案，一种时采用 rust 原生的多生产者多消费者的队列，但是需要在新建节点的时候申明（不一定，也可以在新建节点之后调用可变函数声明），另一种是使用类似ros通讯这样的手段。
使用原生的队列好处在于不需要去构建订阅者，众所周知订阅者需要一个可写的所有权，这要求我们不得不为关键数据加锁，同时我们还需要通过申请发放制度来管理数据的更新迭代。不过想起来了，之前说将监听和发布放在exp中，在exp中运行的话确实不用担心所有权的问题，exp监听到请求之后就可以直接修改对应的值。只是同样的从 planner 中向 controller 发布轨迹点的过程，需要planner向exp发送序列请求，总而言之确实需要两个队列。无论是依赖于通讯还是并发的队列

但是如果采用 SegQueue 的话，就可以无锁的在 rust 系统内高效的传递数据，至少内部的消息传递速度要快的多，同时也能减少额外线程的调用，唯一问题在于 这可能会对将来搭建 recoder 带来些许的问题。

枚举类型是好东西阿，之前解决不了的如何快速调用robot属性的问题解决了。
真能解决吗？似乎也难，还是需要 unsafe 来做到 类型 N 这一步，这是无法避免的，但已经是相当大的进展了。
