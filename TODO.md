# TODO

## 一些idea

* 如何适应多臂环境？
  目前来说，控制器参数由两个部分决定，一方面时控制器类型，一方面时机械臂自身的相关属性。控制不同的机械臂完全可以有不同的控制器参数。
  实际上的控制器应该时一个控制器列表？每个控制器对应一个机械臂。
  那么当不同的控制器会相互作用时作何处理？如需要考虑多机安全避障时出现的控制器协调问题，此时控制器需要其他机械臂参数……吗？
  似乎并不需要，安全避障考虑的因素一共有三个，分别是自身的体积、协同装置的体积、周围环境的体积。三部分约束，对于这些约束或许可以做成接口？
  控制器的列表属于控制器吗？
  我认为是的，就如同机器人的列表也是机器人一样
  唯一的问题在于，这种归属关系可否嵌套？也就是说，可不可能存在一个控制器的列表的列表作为一个控制器？
  规划期、机械臂实体都是这样的，这种分块的嵌套方式。
  这也就意味着，作为控制器的列表，其下的功能或者函数需要抽象一点，只能通过子控制器提供的接口来调用，而并非特化成某种控制器。
  类似Pandas这个列表是缺乏泛用性的，我们是否直到读取文件才能确定这个列表的类型。
  那么如何在编译期确定这个列表的大小和类型呢？
  如果只有引用的话，倒是可以，或者用动态类型？但是在编译期可以正确展开吗？
  不太清楚
  但是这样的好处在于每个控制器一定有唯一的机械臂用于控制
  那么在接收端会好写的多，自动命名或者默认参数都行
* 如何编译
  目前来说，使用静态矩阵的好处就在于可以在代码编写期就可以知道矩阵形状与计算的正确与否，这对于代码的编写过程自然是极大的便利，但是坏处就是在于我们必须在编译之前就获取到相当多的参数，如机械臂结构之类的东西。否则我们将无法决定控制器、规划器等工具的维度。
  虽然可以根据工具的不同直接声明不同的控制器或规划器
  可以绑定一些常数吗，放在对应的robot里面
  似乎是可以的
  拿常数做宏定义是吧
  这种常数是否可以相加呢,验证了不仅仅常数泛型不可以相加，连常数都不可以相加，
  在作为常数类型声明时常数也不许加
  但是声明常数的时候时可以加的
  所以当我们声明控制器和规划器的时候，我们仍然需要加上对应的常数
  这也就意味着我们无法通过读取文件的方式获取实验相关数据
  甚至在运行时作为参数都不行，因为这是编译期就需要决定的内容
  发现可以通过写一个 `build.rs` 解决，这太棒了，他可以分析文件并转为相关代码声明在其中
  但是 `build.rs` 不能够使用 `crates` 中的任何代码，只能作为一个代码生成器使用。
  甚至还能使用条件编译来避免代码编写阶段的分析器报错
  简直太时尚了啊家人们
* 关于robot类的借用。无论是控制器还是规划器，都大概率会需要机械臂作为其可读参数，但是真正能够修改机械臂参数的应该只有ros的回调函数。也就是说所有的控制器或者规划器都应该只有机械臂结构的只读借用，而可变借用只在回调中被使用。但是天杀的可变调用不能有参数啊……我该怎么让回调函数知道该使用robot的可变调用呢？确实是个严重的问题啊……。
* 控制器的ros节点应该声明在哪里呢……理论上来说确实应该只有根节点一个就够了，其他的都是从根节点出发的更新故事……，这不正好？向下传引用呗，在函数中传递节点的引用
* 但是发布者和接受者应该写在哪里呢，理论上来说每个节点都有其各自的发布节点和接受节点和各自的作用域前缀，这也就是说每个节点都该有自己与天同寿的发布者、接收者、以及他们的作用域前缀字符串，要新开一个结构体吗？应该是要的。也就是说需要一个新的结构体，里面有三个变量，一个是发布者列表，一个是接受者列表，一个是作用域前缀字符串，这多好啊，但是发布者对象和接受者对象会是不同的类型吗，会不会是符合奇怪的类型呢
* 关于接收者和发布者的位置，关于机器人的状态参数在simulator中接受，在对应的实物或者仿真器中发布，放在robot/域下面，路径与控制器路径、规划器路径一致。控制器接受机器人参数，并发布控制器参数。发布的内容在controller/域下面真是非常好记啊。
* 关于控制器频率，要考虑给不同的控制器以不同的频率吗？暂时不考虑，之后可以加
* 济川学长想通过可行域重合边界快速获得安全属性。从而减少安全空间中的计算量

* 如何生成机器人架构树。对robot的类型进行模式匹配。当叶节点如 Panda 等实际机器人或者特殊机器人组时。生成对应机器人的读写锁并进入控制器与规划器分拣器。以函数中常数泛型的方式向分拣器说明机器人自由度用于新建控制器与规划器。当是枝节点如 RobotList 时，其下的控制器通常也为 **List.直接创建或者进入分拣器皆可，为了实现流程的一致性建议直接进入。同时，当进入枝节点是，需要递归地构建下一级子节点，在返回时将新构建的子节点加装在结构树上。
* 关于线程树的管理尚无头绪。考虑通过线程池的方式管理。每次开辟新线程时将线程句柄加入线程池。

## 现在还差什么

* ros 通讯与线程协议
* 配置初始化
* 迭代器
